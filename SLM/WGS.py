import numpy as np
import torch
import torch.fft as fft
import matplotlib.pyplot as plt


def WGS_phase_generate(initSLMAmp:torch.Tensor, initSLMPhase:torch.Tensor, targetAmp:torch.Tensor, Loop = 5, threshold = 0.01, Plot:bool = False):
    '''
    This function uses WGS algorithm to generate hologram according to your input targetAmp.
    
    Parameters
    ----------
    initSLMAmp : 2D_tensor
        The amplitude distrubution of the incident laser, typically gaussian distrubution.
    
    initSLMPhase : 2D_tensor
        The phase distrubution of SLM plane for the initial calculation. If generate a new target, use a random initPhase. 
        If generate a series of dynamic targets, use the phase generated by the last WGS.
        
    targetAmp : 2D_tensor
        The amplitude distrubution of the target. 
        
    Loop :
        The number of iteration loops in WGS calculation, typically 5~20 is enough.
        
    threshold :
        The phase fix threshold in WGS calculation. If the non-uniformity < threshold, the phase in focal plane will be fixed.
        
    Plot : 
        Whether to plot non-uniformity vs iteration. Default to be False.
        
    '''

    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    torch.backends.cudnn.benchmark = True

    initSLMAmp = initSLMAmp.to(device)
    initSLMPhase = initSLMPhase.to(device)
    targetAmp = targetAmp.to(device)

    SLM_Field = torch.multiply(initSLMAmp, torch.exp(1j*initSLMPhase))
    targetAmp = targetAmp/torch.sqrt(torch.sum(torch.square(targetAmp)))
    targetAmpmask = (targetAmp != 0)*1
    # targetAmpmask = (targetAmp > 0)*1
    totalsites = torch.count_nonzero(targetAmp)

    count = 0
    g_coeff0 = torch.ones(1).to(device)
    Focal_phase = torch.zeros_like(targetAmp).to(device)
    fftAmp = torch.zeros_like(targetAmp).to(device)
    non_uniform = torch.zeros(Loop).to(device)

    targetAmp_weightfactor = torch.abs(targetAmp) / torch.sum(torch.abs(targetAmp))

    while count < Loop:
        fftSLM = fft.fft2(SLM_Field)
        fftSLMShift = fft.fftshift(fftSLM)
        fftSLM_norm = torch.sqrt(torch.sum(torch.square(torch.abs(fftSLMShift))))
        fftSLMShift_norm = fftSLMShift / fftSLM_norm

        fftAmp = torch.abs(fftSLMShift_norm)
        fftAmp_foci = torch.multiply(fftAmp, targetAmpmask)

        non_uniform[count] = nonUniformity_adapt(fftAmp_foci, targetAmp, totalsites)

        fftAmp_foci_avg = torch.multiply(torch.sum(fftAmp_foci) / totalsites, targetAmpmask)

        g_coeff = torch.where(fftAmp_foci != 0, torch.multiply(torch.div(torch.multiply(fftAmp_foci_avg, targetAmp_weightfactor), fftAmp_foci),g_coeff0), torch.zeros_like(fftAmp_foci_avg).to(device))                      
                                                
        Focal_Amp = torch.multiply(targetAmp, g_coeff)

        if non_uniform[count] > threshold or count == 0:
            Focal_phase0 = torch.angle(fftSLMShift_norm)
        else:
            Focal_phase0 = Focal_phase
        # Focal_phase0 = torch.angle(fftSLMShift_norm)
        
        Focal_phase = Focal_phase0
        Focal_Field = torch.multiply(Focal_Amp, torch.exp(1j * Focal_phase))

        SLM_Field = fft.ifft2(fft.ifftshift(Focal_Field))
        SLM_Phase = torch.angle(SLM_Field)

        SLM_Field = torch.multiply(initSLMAmp, torch.exp(1j * SLM_Phase))
        g_coeff0 = g_coeff
        count += 1

    # SLM_Amp = torch.abs(SLM_Field)
    SLM_Phase = torch.angle(SLM_Field)
    
    if Plot:
            plt.plot(non_uniform.cpu())
            plt.grid()
            plt.yscale('log')
            plt.xlabel('Iteration')
            plt.ylabel('Non-uniformity')
            plt.show()

    return SLM_Phase


def WGS3D_phase_generate(initSLMAmp:torch.Tensor, initSLMPhase:torch.Tensor, targetAmp:torch.Tensor, targetLayer:torch.Tensor, Loop = 5, threshold = 0.01, Plot:bool = False):
    '''
    This function uses 3D WGS algorithm to generate hologram according to your input targetAmp.
    
    Parameters
    ----------
    initSLMAmp : 2D_tensor
        The amplitude distrubution of the incident laser, typically gaussian distrubution.
    
    initSLMPhase : 2D_tensor
        The phase distrubution of SLM plane for the initial calculation. If generate a new target, use a random initPhase. 
        If generate a series of dynamic targets, use the phase generated by the last WGS.
        
    targetAmp : 3D_tensor
        Containing multi layers of targetAmp. [targetAmp1, targetAmp2, targetAmp3...]
    
    targetLayer : 1D_tensor
        Representing the position of each target layer relative to the actual focal plane. The unit is um. [z1, z2, z3...]
        
    Loop :
        The number of iteration loops in WGS calculation, typically 5~20 is enough.
        
    threshold :
        The phase fix threshold in WGS calculation. If the non-uniformity < threshold, the phase in focal plane will be fixed.
        
    Plot : 
        Whether to plot non-uniformity vs iteration. Default to be False.
         
    '''

    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    torch.backends.cudnn.benchmark = True

    initSLMAmp = initSLMAmp.to(device)
    initSLMPhase = initSLMPhase.to(device)
    targetAmp = targetAmp.to(device)
    
    layer_num = targetLayer.shape[0]

    SLM_Field = torch.multiply(initSLMAmp, torch.exp(1j*initSLMPhase))
    targetAmp = targetAmp/torch.sqrt(torch.sum(torch.square(targetAmp)))
    targetAmpmask = (targetAmp > 0)*1
    totalsites = torch.count_nonzero(targetAmp)

    count = 0
    g_coeff0 = torch.ones(1).to(device)
    Focal_phase = torch.zeros_like(targetAmp).to(device)
    # Note: the dtype of the following two tensors must be specified to torch.complex.
    Propagation_Field = torch.zeros_like(targetAmp, dtype=torch.complex128).to(device)
    Backpropagation_Field = torch.zeros_like(targetAmp, dtype=torch.complex128).to(device)
    non_uniform = torch.zeros(Loop).to(device)

    targetAmp_weightfactor = torch.abs(targetAmp) / torch.sum(torch.abs(targetAmp))

    while count < Loop:
        
        for i in range(layer_num):
            layer = targetLayer[i]
            Propagation_Field[i] = fft.fftshift(fft.fft2( torch.multiply(SLM_Field, torch.exp(-1j*fresnel_lens_phase_generate(layer))) ))
            
        Propagation_Field_norm_coeff = torch.sqrt(torch.sum(torch.square(torch.abs(Propagation_Field))))
        Propagation_Field_norm = Propagation_Field/Propagation_Field_norm_coeff
        
        Propagation_Amp = torch.abs(Propagation_Field_norm)
        Propagation_Amp_foci = torch.multiply(Propagation_Amp, targetAmpmask)

        non_uniform[count] = nonUniformity_adapt(Propagation_Amp_foci, targetAmp, totalsites)
        
        Propagation_Amp_foci_avg = torch.multiply(torch.sum(Propagation_Amp_foci) / totalsites, targetAmpmask)
        g_coeff = torch.where(Propagation_Amp_foci != 0, torch.multiply(torch.div(torch.multiply(Propagation_Amp_foci_avg, targetAmp_weightfactor), Propagation_Amp_foci),g_coeff0), torch.zeros_like(Propagation_Amp_foci_avg).to(device))                                             
        Focal_Amp = torch.multiply(targetAmp, g_coeff)

        if non_uniform[count] > threshold or count == 0:
            Focal_phase0 = torch.angle(Propagation_Field_norm)
        else:
            Focal_phase0 = Focal_phase
        
        Focal_phase = Focal_phase0
        Focal_Field = torch.multiply(Focal_Amp, torch.exp(1j * Focal_phase))
        
        for i in range(layer_num):
            layer = targetLayer[i]
            # Backpropagation_Field[i] = fft.ifft2(fft.ifftshift( torch.multiply(Focal_Field[i], torch.exp(1j*fresnel_lens_phase_generate(layer))) ))
            Backpropagation_Field[i] = torch.multiply(fft.ifft2(fft.ifftshift(Focal_Field[i])), torch.exp(1j*fresnel_lens_phase_generate(layer)))
    
        SLM_Field = Backpropagation_Field.sum(axis=0)
        SLM_Phase = torch.angle(SLM_Field)

        SLM_Field = torch.multiply(initSLMAmp, torch.exp(1j * SLM_Phase))
        g_coeff0 = g_coeff
        count += 1

    # SLM_Amp = torch.abs(SLM_Field)
    SLM_Phase = torch.angle(SLM_Field)
    
    if Plot:
            plt.plot(non_uniform.cpu())
            plt.grid()
            plt.yscale('log')
            plt.xlabel('Iteration')
            plt.ylabel('Non-uniformity')
            plt.show()

    return SLM_Phase


def fresnel_lens_phase_generate(shift_distance, SLMRes=(4096,4096), x0=2048, y0=2048, pixelpitch=17,wavelength=0.813,focallength=4000,magnification=0.375):
        '''
        the fresnel lens phase, see notion for more details.
        '''
        
        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        torch.backends.cudnn.benchmark = True

        Xps, Yps = torch.meshgrid(torch.linspace(0, SLMRes[0], SLMRes[0]), torch.linspace(0, SLMRes[1], SLMRes[1]))
        Xps = Xps.to(device)
        Yps = Yps.to(device)

        X = (Xps-x0)*pixelpitch
        Y = (Yps-y0)*pixelpitch

        fresnel_lens_phase = torch.fmod(torch.pi*(X**2+Y**2)*shift_distance/(wavelength*focallength**2)*magnification**2,2*torch.pi)

        return fresnel_lens_phase
    

def nonUniformity_adapt(Amp_foci, targetAmp_adapt, totalsites):
    '''
    This function calculates the nonUniformity with the non-uniform targetAmp distribution.
    Amp_foci is the field amplitude at the focal plane. It is a tensor.
    targetAmp_adapt is the non-uniform targetAmp distribution.
    '''
    Inten_foci = torch.square(Amp_foci) / torch.sum(torch.square(Amp_foci))
    Inten_foci_nonzero = torch.abs(Inten_foci[Inten_foci != 0])
    Inten_adapt = torch.square(targetAmp_adapt) / torch.sum(torch.square(targetAmp_adapt))
    Inten_adapt_nonzero = torch.abs(Inten_adapt[Inten_adapt != 0])
    non_Uniform = torch.sqrt(torch.sum(torch.square(Inten_foci_nonzero - Inten_adapt_nonzero))) / totalsites / torch.mean(Inten_adapt_nonzero)
    
    return non_Uniform


def phase_to_screen(SLM_Phase):
    '''
    This function converts the SLM_Phase calculated by WGS to  fit to the SLM screen.
    Temporarily for 4096*4096 phase to 1024*1272 screen.
    '''
    SLM_IMG = SLM_Phase[1536:2560, 1536:2560]
    SLM_bit = np.around((SLM_IMG+np.pi)/(2*np.pi)*255).astype('uint8')
    
    return SLM_bit


def phase_to_screen_cuda(SLM_Phase):
    device = "cuda"
    SLM_Phase = SLM_Phase.to(device)
    SLM_IMG = SLM_Phase[1536:2560, 1536:2560]
    SLM_bit = torch.round((SLM_IMG + torch.pi) / (2 * torch.pi) * 255).to(dtype=torch.uint8)


    return SLM_bit


def slm_screen_correct(slm_screen, fresnel_lens_screen, slm_correction, LUT):
    # slm_screen_f = np.mod(slm_screen + self.fresnel_lens_screen, 256)
    # slm_screen_f_corrected = np.mod(slm_screen_f + self.slm_correction, 256)
    # slm_screen_f_corrected_LUT = np.around(slm_screen_f_corrected*self.LUT/255).astype('uint8')
    
    # return slm_screen_f_corrected_LUT
    slm_screen_f = slm_screen + fresnel_lens_screen
    slm_screen_f_corrected = slm_screen_f + slm_correction
    slm_screen_f_corrected_LUT = torch.round(slm_screen_f_corrected * LUT).to(torch.uint8)
    slm_screen_f_corrected_LUT_cpu = slm_screen_f_corrected_LUT.clone().cpu().numpy()

    return slm_screen_f_corrected_LUT_cpu


